import * as dm from "@jsr/iroha__core/data-model";
import { getCodec } from "@jsr/iroha__core";
import { ENDPOINT_BLOCKS_STREAM, ENDPOINT_EVENTS } from "./const.js";
import { setupWebSocket } from "./util.js";
import { nativeWS } from "./web-socket/mod.js";
import pDefer from "p-defer";
/**
 * Lower-level client
 */ export class WebSocketAPI {
  toriiBaseURL;
  adapter;
  /**
   * Create an instance.
   * @param toriiBaseURL Torii base URL
   * @param adapter A custom WebSocket adapter. Uses native by default.
   * See the {@linkcode [web-socket]} module for more details.
   */ constructor(toriiBaseURL, adapter){
    this.toriiBaseURL = toriiBaseURL;
    this.adapter = adapter ?? nativeWS;
  }
  // TODO: refine the API with async generator; document, provide code sample
  // TODO: provide dispose symbol
  async blocksStream(params) {
    const { ee, send: sendRaw, isClosed, close, accepted } = setupWebSocket({
      baseURL: this.toriiBaseURL,
      endpoint: ENDPOINT_BLOCKS_STREAM,
      adapter: this.adapter
    });
    ee.on('open', ()=>{
      sendRaw(getCodec(dm.BlockStreamMessage).encode(dm.BlockStreamMessage.Subscribe({
        height: params?.fromBlockHeight?.map(BigInt) ?? new dm.NonZero(1n)
      })).buffer);
    });
    ee.on('message', (raw)=>{
      const block = getCodec(dm.BlockStreamMessage).decode(raw);
      if (block.kind !== 'Block') throw new TypeError(`Expected a block, got BlockStreamMessage::${block.kind}`);
      ee.emit('block', block.value);
    });
    await accepted();
    const stream = lazyBlocks(ee, ()=>sendRaw(getCodec(dm.BlockStreamMessage).encode(dm.BlockStreamMessage.Next).buffer));
    return {
      stream,
      ee: // Emittery typing bug
      ee,
      stop: close,
      isClosed
    };
  }
  async events(params) {
    const { ee, isClosed, close, accepted, send: sendRaw } = setupWebSocket({
      baseURL: this.toriiBaseURL,
      endpoint: ENDPOINT_EVENTS,
      adapter: this.adapter
    });
    ee.on('open', ()=>{
      sendRaw(getCodec(dm.EventSubscriptionRequest).encode({
        filters: params?.filters ?? []
      }).buffer);
    });
    ee.on('message', (raw)=>{
      const event = getCodec(dm.EventBox).decode(raw);
      ee.emit('event', event);
    });
    await accepted();
    return {
      stop: close,
      ee: // Emittery typing bug :<
      ee,
      isClosed
    };
  }
}
async function* lazyBlocks(ee, sendNext) {
  while(true){
    sendNext();
    const resultDeferred = pDefer();
    ee.once('close').then(()=>resultDeferred.resolve({
        t: 'halt'
      }));
    ee.once('block').then((block)=>resultDeferred.resolve({
        t: 'cont',
        block
      }));
    const result = await resultDeferred.promise;
    if (result.t === 'cont') yield result.block;
    else return;
  }
}
//# sourceMappingURL=api-ws.js.map